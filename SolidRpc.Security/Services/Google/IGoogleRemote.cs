using System.Threading.Tasks;
using System.Collections.Generic;
using System;
using System.Threading;
using SolidRpc.Security.Types;
namespace SolidRpc.Security.Services.Google {
    /// <summary>
    /// Defines access to the google oauth implementation
    /// </summary>
    public interface IGoogleRemote {
        /// <summary>
        /// Authorizes a user @ google
        /// </summary>
        /// <param name="clientId">The client ID string that you obtain from the API Console, as described in Obtain OAuth 2.0 credentials.</param>
        /// <param name="responseType">The client ID string that you obtain from the API Console, as described in Obtain OAuth 2.0 credentials.</param>
        /// <param name="scope">The client ID string that you obtain from the API Console, as described in Obtain OAuth 2.0 credentials.</param>
        /// <param name="nounce">A random value generated by your app that enables replay protection.</param>
        /// <param name="redirectUri">should be the HTTP endpoint on your server that will receive the response from Google. The value must exactly match one of the authorized redirect URIs for the OAuth 2.0 client, which you configured in the API Console. If this value doesn't match an authorized URI, you will get a 'redirect_uri_mismatch' error.</param>
        /// <param name="state">An opaque string that is round-tripped in the protocol; that is to say, it is returned as a URI parameter in the Basic flow, and in the URI #fragment in the Implicit flow. The state can be useful for correlating requests and responses. Because your redirect_uri can be guessed, using a state value can increase your assurance that an incoming connection is the result of an authentication request. If you generate a random string or encode the hash of some client state (e.g., a cookie) in this state variable, you can validate the response to additionally ensure that the request and response originated in the same browser. This provides protection against attacks such as cross-site request forgery.</param>
        /// <param name="prompt"></param>
        /// <param name="display">An ASCII string value for specifying how the authorization server displays the authentication and consent user interface pages. The following values are specified, and accepted by the Google servers, but do not have any effect on its behavior: page, popup, touch, and wap.</param>
        /// <param name="loginHint">can be the user's email address or the sub string, which is equivalent to the user's Google ID. If you do not provide a login_hint and the user is currently logged in, the consent screen includes a request for approval to release the userâ€™s email address to your app</param>
        /// <param name="includeGrantedScopes">If this is provided with the value true, and the authorization request is granted, the authorization will include any previous authorizations granted to this user/application combination for other scopes; see Incremental Authorization. Note that you cannot do incremental authorization with the Installed App flow.</param>
        /// <param name="accessType">The allowed values are offline and online. The effect is documented in Offline Access; if an access token is being requested, the client does not receive a refresh token unless offline is specified.</param>
        /// <param name="openidRealm">openid.realm is a parameter from the OpenID 2.0 protocol, not from OAuth 2.0. It is used in OpenID 2.0 requests to signify the URL-space for which an authentication request is valid. Use openid.realm if you are migrating an existing application from OpenID 2.0 to OpenID Connect.</param>
        /// <param name="hd">The hd (hosted domain) parameter streamlines the login process for G Suite hosted accounts. By including the domain of the G Suite user (for example, mycollege.edu), you can indicate that the account selection UI should be optimized for accounts at that domain. To optimize for G Suite accounts generally instead of just one domain, use an asterisk: hd=*. Don't rely on this UI optimization to control who can access your app, as client-side requests can be modified. Be sure to validate that the returned ID token has an hd claim value that matches what you expect (e.g. mycolledge.edu). Unlike the request parameter, the ID token claim is contained within a security token from Google, so the value can be trusted.</param>
        /// <param name="cancellationToken"></param>
        Task Authorize(
            string clientId,
            IEnumerable<string> responseType,
            IEnumerable<string> scope,
            string nounce,
            Uri redirectUri,
            string state = default(string),
            string prompt = default(string),
            string display = default(string),
            string loginHint = default(string),
            bool includeGrantedScopes = default(bool),
            string accessType = default(string),
            string openidRealm = default(string),
            string hd = default(string),
            CancellationToken cancellationToken = default(CancellationToken));
    
        /// <summary>
        /// Returns the openid configuration
        /// </summary>
        /// <param name="cancellationToken"></param>
        Task<OpenIDConnnectDiscovery> OpenIdConfiguration(
            CancellationToken cancellationToken = default(CancellationToken));
    
        /// <summary>
        /// Returns the openid keys used for signing.
        /// </summary>
        /// <param name="cancellationToken"></param>
        Task<OpenIDKeys> OpenIdKeys(
            CancellationToken cancellationToken = default(CancellationToken));
    
    }
}